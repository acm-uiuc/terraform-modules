{
  "version": 3,
  "sources": ["../../src/api/warmer/lambda.ts"],
  "sourcesContent": ["import {\n  LambdaClient,\n  InvokeCommand,\n  InvokeWithResponseStreamCommand,\n} from \"@aws-sdk/client-lambda\";\nimport { TextDecoder } from \"util\";\n\n// --- AWS SDK Clients and Utilities ---\nconst lambdaClient = new LambdaClient({});\nconst textDecoder = new TextDecoder();\n\n// --- Invocation Logic for Standard Lambdas ---\n\n/**\n * Invokes a batch of standard (non-streaming) Lambdas concurrently.\n */\nasync function invokeStandardBatch(\n  lambdaName: string,\n  count: number,\n): Promise<Set<string>> {\n  const invocationPromises = Array.from({ length: count }, () =>\n    lambdaClient.send(\n      new InvokeCommand({\n        FunctionName: lambdaName,\n        Payload: JSON.stringify({ action: \"warmer\" }),\n      }),\n    ),\n  );\n\n  const results = await Promise.allSettled(invocationPromises);\n  const foundInstanceIds = new Set<string>();\n\n  results.forEach((result) => {\n    if (result.status === \"fulfilled\" && result.value.Payload) {\n      try {\n        const payloadString = textDecoder.decode(result.value.Payload);\n        const body = JSON.parse(payloadString);\n        if (body.instanceId) {\n          foundInstanceIds.add(body.instanceId);\n        }\n      } catch (e) {\n        console.error(\"Error parsing payload from standard function:\", e);\n      }\n    } else if (result.status === \"rejected\") {\n      console.error(\"Standard invocation failed:\", result.reason.message);\n    }\n  });\n\n  return foundInstanceIds;\n}\n\n// --- Invocation Logic for Streaming Lambdas ---\n\n/**\n * Invokes a batch of response-streaming Lambdas concurrently.\n */\nasync function invokeStreamingBatch(\n  lambdaName: string,\n  count: number,\n): Promise<Set<string>> {\n  const invocationPromises = Array.from({ length: count }, () =>\n    lambdaClient.send(\n      new InvokeWithResponseStreamCommand({\n        FunctionName: lambdaName,\n        Payload: JSON.stringify({ action: \"warmer\" }),\n      }),\n    ),\n  );\n\n  const results = await Promise.allSettled(invocationPromises);\n  const foundInstanceIds = new Set<string>();\n\n  for (const result of results) {\n    if (result.status === \"fulfilled\" && result.value.EventStream) {\n      try {\n        const chunks: Uint8Array[] = [];\n        // Iterate over the EventStream to get data chunks\n        for await (const event of result.value.EventStream) {\n          if (event.PayloadChunk && event.PayloadChunk.Payload) {\n            chunks.push(event.PayloadChunk.Payload);\n          }\n        }\n\n        const payloadString = textDecoder.decode(Buffer.concat(chunks));\n        const body = JSON.parse(payloadString);\n        if (body.instanceId) {\n          foundInstanceIds.add(body.instanceId);\n        }\n      } catch (e) {\n        console.error(\"Error processing stream from streaming function:\", e);\n      }\n    } else if (result.status === \"rejected\") {\n      console.error(\"Streaming invocation failed:\", result.reason.message);\n    }\n  }\n\n  return foundInstanceIds;\n}\n\n// --- Main Lambda Handler ---\n\n/**\n * Main handler that warms a target Lambda function by invoking it multiple times.\n * It can handle both standard and response-streaming target functions.\n */\nexport const handler = async (event: {}) => {\n  const { lambdaName, numInstancesStr, maxWavesStr, isStreaming } = {\n    lambdaName: process.env.LAMBDA_NAME,\n    numInstancesStr: process.env.NUM_INSTANCES,\n    maxWavesStr: process.env.MAX_WAVES,\n    isStreaming: (process.env.IS_STREAMING || \"false\").toLowerCase() === \"true\", // e.g., 'true' or 'false'\n  };\n\n  if (!lambdaName || !numInstancesStr) {\n    throw new Error(\"Env vars 'LAMBDA_NAME' and 'NUM_INSTANCES' are required.\");\n  }\n\n  const numInstances = parseInt(numInstancesStr, 10);\n  const maxWaves = parseInt(maxWavesStr || \"5\", 10);\n\n  let totalInvocations = 0;\n  let wavesCompleted = 0;\n  const uniqueInstanceIds = new Set<string>();\n\n  console.log(`Warming target: ${lambdaName} (Streaming: ${isStreaming})`);\n\n  for (let i = 1; i <= maxWaves; i++) {\n    wavesCompleted = i;\n    const neededCount = numInstances - uniqueInstanceIds.size;\n    if (neededCount <= 0) {\n      console.log(\"Target met. No more waves needed.\");\n      break;\n    }\n\n    console.log(`-- - Wave ${i} of ${maxWaves} --- `);\n\n    // Choose the correct invoker function based on the flag\n    const newIds = isStreaming\n      ? await invokeStreamingBatch(lambdaName, numInstances)\n      : await invokeStandardBatch(lambdaName, numInstances);\n\n    totalInvocations += numInstances;\n\n    newIds.forEach((id) => uniqueInstanceIds.add(id));\n\n    console.log(\n      `Wave ${i} complete.Found ${uniqueInstanceIds.size} of ${numInstances} unique instances.`,\n    );\n  }\n\n  console.log(\n    `Warming complete.Found ${uniqueInstanceIds.size} unique instances from ${totalInvocations} total invocations over ${wavesCompleted} waves.`,\n  );\n\n  return {\n    statusCode: 200,\n    body: JSON.stringify({\n      targetInstances: numInstances,\n      warmedInstances: uniqueInstanceIds.size,\n      totalInvocations,\n      wavesCompleted,\n      instanceIds: [...uniqueInstanceIds],\n    }),\n  };\n};\n\n// --- Local Test Execution Block ---\n\n// This block runs only when the file is executed directly (e.g., `node index.js`)\nif (import.meta.url === `file://${process.argv[1]}`) {\n  // --- Configuration for local testing ---\n  process.env.LAMBDA_NAME = \"my-target-lambda-function-name\";\n  process.env.NUM_INSTANCES = \"3\";\n  process.env.MAX_WAVES = \"5\";\n  process.env.IS_STREAMING = \"false\"; // Set to 'true' to test streaming\n\n  console.log(\"Running warmer in local test mode...\");\n  handler({}).then(result => {\n    console.log(\"\\n--- Final Result ---\");\n    console.log(JSON.parse(result.body));\n  }).catch(error => {\n    console.error(\"Local test run failed:\", error);\n  });\n}\n"],
  "mappings": "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",
  "names": ["LambdaClient", "InvokeCommand", "InvokeWithResponseStreamCommand", "TextDecoder", "lambdaClient", "textDecoder", "invokeStandardBatch", "lambdaName", "count", "invocationPromises", "results", "foundInstanceIds", "result", "payloadString", "body", "e", "invokeStreamingBatch", "chunks", "event", "handler", "numInstancesStr", "maxWavesStr", "isStreaming", "numInstances", "maxWaves", "totalInvocations", "wavesCompleted", "uniqueInstanceIds", "i", "newIds", "id", "error"]
}
